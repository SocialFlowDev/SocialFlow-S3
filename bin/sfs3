#!/usr/bin/perl

use strict;
use warnings;
use feature qw( say switch );
no if $] >= 5.017011, warnings => 'experimental::smartmatch';

use SocialFlow::S3;

use IO::Async::Loop;

use File::Basename qw( basename );
use Getopt::Long;
use YAML qw( LoadFile );

Getopt::Long::Configure(qw(bundling pass_through ));

GetOptions(
   'C|config=s' => \(my $CONFIG_FILE = "$ENV{HOME}/.sfs3.conf"),
   'q|quiet'    => \my $QUIET,
) or do_help(), exit 1;

Getopt::Long::Configure(qw( no_pass_through ));

sub config {
  # YAML::LoadFile doesn't give nice errors when the file doens't exist.
  unless ( -e $CONFIG_FILE ) {
    print STDERR "Config file $CONFIG_FILE doesn't exist\n";
    exit 1;
  }
  my $config = LoadFile( $CONFIG_FILE );

  for my $req_key ( qw/access_key secret_key bucket/ ) {
    unless ( exists $config->{$req_key} ) {
      print STDERR "Cofing was missing required key $req_key\n";
      exit 1;
    }
  }

  $config;
}

# Don't load the config file until we actually need it
sub s3
{
   my $config = config( $_[0] );

   my $loop = IO::Async::Loop->new;
   my $s3 = SocialFlow::S3->new(
      quiet => $QUIET,
      ( map { $_ => $config->{$_} }
         qw( access_key secret_key bucket ssl crypto_keyid ) ),
   );
   $loop->add( $s3 );
   $s3
}

sub do_help
{
   print STDERR <<'EOF';

Usage: sfs3 COMMAND [--config=file] [OPTIONS...]

Commands:
   ls [--long] [--recursive] S3PATH
   cat S3FILE
   uncat [--force] S3FILE
   get [--force] S3FILE [LOCALFILE]
   put LOCALFILE [S3FILE]
   rm S3PATTERN
   version

   push LOCALROOT S3ROOT
     [--concurrent=N] [--all] [--md5sum] [--only=PATTERN]* [--exclude=PATTERN]*

   pull S3ROOT LOCALROOT
     [--concurrent=N] [--all] [--md5sum] [--only=PATTERN]* [--exclude=PATTERN]*

Patterns:
  May contain wildcards
    ?  A single character, not '/'
    *  Zero or more characters, not '/'
    ** Zero or more characters, including '/'

EOF
}

## main
given( shift @ARGV ) {
   when([ undef, "help" ]) {
      do_help;
      exit 0;
   }

   when( "version" ) {
     print "sfs3 version: $SocialFlow::S3::VERSION\n";
   }

   when( "ls" ) {
      GetOptions(
         'l|long' => \my $LONG,
         'r|recursive' => \my $RECURSE,
      ) or exit 1;
      my $s3path = shift @ARGV;

      s3()->cmd_ls( $s3path, long => $LONG, recurse => $RECURSE );
   }
   when( "cat" ) {
      GetOptions(
      ) or exit 1;
      my $s3path = shift @ARGV;

      s3()->cmd_cat( $s3path );
   }
   when( "uncat" ) {
      GetOptions(
         'f|force' => \my $FORCE,
      ) or exit 1;
      my $s3path = shift @ARGV;

      s3()->cmd_uncat( $s3path, no_overwrite => !$FORCE );
   }
   when( "get" ) {
      GetOptions(
         'f|force' => \my $FORCE,
      ) or exit 1;
      my $s3path = shift @ARGV;
      my $localpath = shift @ARGV // basename( $s3path );

      s3()->cmd_get( $s3path, $localpath, no_overwrite => !$FORCE );
   }
   when( "put" ) {
      GetOptions(
         'f|force' => \my $FORCE,
      ) or exit 1;
      my $localpath = shift @ARGV;
      my $s3path = shift @ARGV;
      if( !defined $s3path ) {
         $s3path = basename( $localpath );
      }
      elsif( $s3path =~ m{/$} ) {
         $s3path .= basename( $localpath );
      }

      s3()->cmd_put( $localpath, $s3path, no_overwrite => !$FORCE );
   }
   when( "rm" ) {
      GetOptions(
      ) or exit 1;
      my $s3path = shift @ARGV;

      s3()->cmd_rm( $s3path );
   }
   when( "push" ) {
      my $SKIP_LOGIC;
      GetOptions(
         'c|concurrent=i' => \my $CONCURRENT,
         'a|all'          => sub { $SKIP_LOGIC = "all" },
         '5|md5sum'       => sub { $SKIP_LOGIC = "md5sum" },
         'only=s'         => \my @ONLYS,
         'exclude=s'      => \my @EXCLUDES,
      ) or exit 1;
      my $localroot = shift @ARGV;
      my $s3root = shift @ARGV // $localroot;

      s3()->cmd_push( $localroot, $s3root,
         concurrent => $CONCURRENT,
         skip_logic => $SKIP_LOGIC,
         only => \@ONLYS, exclude => \@EXCLUDES,
      );
   }
   when( "pull" ) {
      my $SKIP_LOGIC;
      GetOptions(
         'c|concurrent=i' => \my $CONCURRENT,
         'a|all'          => sub { $SKIP_LOGIC = "all" },
         '5|md5sum'       => sub { $SKIP_LOGIC = "md5sum" },
         'only=s'         => \my @ONLYS,
         'exclude=s'      => \my @EXCLUDES,
      ) or exit 1;
      my $s3root = shift @ARGV;
      my $localroot = shift @ARGV // $s3root;

      s3()->cmd_pull( $s3root, $localroot,
         concurrent => $CONCURRENT,
         skip_logic => $SKIP_LOGIC,
         only => \@ONLYS, exclude => \@EXCLUDES,
      );
   }

   # ll for "low-level" commands; access directly onto the base "filesystem"
   # of S3 rather than data/metadata layer on top. Useful for debugging and
   # development
   when( "ll-ls" ) {
      my $s3path = shift @ARGV;
      my ( $keys, $prefixes ) = s3()->{s3}->list_bucket(
         prefix => $s3path, delimiter => "/",
      )->get;
      print "$_->{key}\n" for @$keys;
      print "$_\n" for @$prefixes;
   }
   when( "ll-head" ) {
      my $s3path = shift @ARGV;
      my ( $header, $meta ) = s3()->{s3}->head_object(
         key => $s3path,
      )->get;
      $header->scan( sub {
         print "$_[0]: $_[1]\n";
      });
   }
   when( "ll-cat" ) {
      my $s3path = shift @ARGV;
      print scalar s3()->{s3}->get_object(
         key => $s3path,
      )->get;
   }
   when( "ll-uncat" ) {
      my $s3path = shift @ARGV;
      s3()->{s3}->put_object(
         key => $s3path,
         value => do { local $/; scalar <STDIN> },
      )->get;
   }
   when( "ll-rm" ) {
      my $s3path = shift @ARGV;
      s3()->{s3}->delete_object(
         key => $s3path,
      )->get;
   }

   default {
      print STDERR "Unrecognised subcommand '$_'\n";
      do_help;
      exit 1;
   }
}

#!/usr/bin/perl

use strict;
use warnings;

use Test::More;

use SocialFlow::S3;
use t::Mocking;
use t::MockS3;
use HTTP::Response;

use IO::Async::Loop;

BEGIN {
   # gpg gets upset if these files are readable or writable by anyone else
   foreach my $f (qw( t/gnupg t/gnupg/pubring.gpg t/gnupg/secring.gpg t/gnupg/trustdb.gpg )) {
      my $perm = ( stat $f )[2];
      if( $perm & 077 ) {
         print STDERR "Fixing permissions of $f\n";
         chmod $perm & 0700, $f;
      }
   }

   # Use the GnuPG keyring supplied in t/
   $ENV{GNUPGHOME} = "t/gnupg";
}

my $sfs3 = SocialFlow::S3->new(
   s3     => my $s3 = t::MockS3->new,
   bucket => "bucket-name/with-prefix",
   quiet  => 1,

   crypto_keyid => "F55ADE45",
);
IO::Async::Loop->new->add( $sfs3 );

my $plaintext_content = "A secret value we want encrypted";

# Because of the random IV generated by GnuPG we can't know the exact
# ciphertext this will produce. We'll just store it during PUT then replay it
# back to GET
my %ciphertext_meta;
my $ciphertext_content;
my $ciphertext_md5sum;

# put
{
   $s3->EXPECT_put_object(
      key => "data/secret"
   )->RETURN_WITH( sub {
      my %args = @_;
      my $gen_parts = $args{gen_parts};
      %ciphertext_meta = %{ $args{meta} };

      while( my @part = $gen_parts->() ) {
         # $part[0] should be a Future
         $ciphertext_content .= $part[0]->get;
      }

      # MD5sum and length in bytes
      return Future->new->done( "ABC", 21 );
   });

   $s3->EXPECT_put_object(
      key => "meta/secret/md5sum"
   )->RETURN_WITH( sub {
      my %args = @_;
      $ciphertext_md5sum = $args{value};

      return Future->new->done( "ETAG", 32 );
   });

   # Can't just pass an in-memory filehandle as IO::Async won't like it
   pipe( my ( $rd, $wr ) ) or die "Cannot pipe() - $!";
   $wr->print( $plaintext_content );
   $wr->close;

   my $f = $sfs3->_put_file_from_fh( $rd, "secret", mtime => 1381105606 );

   no_more_expectations_ok;

   $f->get;

   # Test that the PUT file does at least start with PGP file magic
   # 0x85 ## PGP old format, type 1 == encrypted message, 2 length octets
   #  ?   ## length
   #  ?   ## length
   # 0x03 ## encrypted data version
   ok( $ciphertext_content =~ m/^\x85..\x03/, 'Ciphertext starts with PGP magic' );

   is( $ciphertext_meta{Keyid}, "F55ADE45", 'Ciphertext put with Keyid meta' );

   # printf STDERR "CIPHERTEXT:\n%v02x\n", $ciphertext_content;
}

{
   $s3->EXPECT_get_object(
      key => "meta/secret/md5sum"
   )->RETURN_F(
      $ciphertext_md5sum,
   );

   $s3->EXPECT_get_object(
      key => "data/secret"
   )->RETURN_WITH( sub {
      my %args = @_;
      my $on_chunk = $args{on_chunk};
      my $header = HTTP::Response->new( 200, "OK",
         [
            "X-Amz-Meta-Keyid" => $ciphertext_meta{Keyid},
         ] );
      $on_chunk->( $header, $ciphertext_content );
      $on_chunk->( $header, undef );
      return Future->new->done( $ciphertext_content, $header, { %ciphertext_meta } );
   });

   my $got_content = "";
   my $f = $sfs3->_get_file_to_code(
      "secret", sub { $got_content .= $_[1] if defined $_[1] }
   );

   no_more_expectations_ok;

   $f->get;

   is( $got_content, $plaintext_content, 'content of file' );
}

done_testing;
